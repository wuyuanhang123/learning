先充值再消费

充值模块：
对接接口：招行接口
业务流程：
1.前端页面点击充值按钮发起充值请求
2.后端接受请求，生成充值订单（cmb_order）生成订单号：redisTemplate.opsForValue.increment(原子自增、线程安全)，（包含金额，订单号）
3.封装订单参数返回前端，前端跳转到招行支付页面
4.前端点击支付，招行内部进行充值扣费
5.招行内部扣费成功后，调用我们系统提供的回调地址
6.通过之前提供给招行的字段，获取到该充值用户的账户，并进行系统内的充值
（重复回调，执行时间过长引发的死锁问题）
：
重复回调问题：
银行的对于充值回调地址有重试机制，如果一定时间内被调用接口没有响应成功，则银行接口会进行重试。 而当网络不好或数据量增大导致系统性能下降时，就有可能会产生在规定时间内没有响应成功的问题，于是银行接口进行重试，系统内则出现多笔充值记录

解决：
系统充值成功后，将该订单设置在redis中，当有充值请求过来时先判断该订单是否已完成，完成则直接响应成功

死锁问题：
由于系统内部在充值成功后会发送一条消息到招行，使用http协议，当网络不稳定时，会出现发送消息比较慢的情况，回调接口没能即时响应，触发银行接口的重试机制，当银行接口发来第二次请求时，第一次请求的事务仍卡在发送消息上，两个事务又都是修改同一个数据，所以出现了死锁

解决：
发送消息的逻辑采用异步处理

知识点：
死锁的产生及解决方案
1.查询占用锁的事务，kill掉
程序上：
1.处理表数据的顺序要相同
2.防止重复点击（前端限制，后端利用缓存作限制）
3.乐观锁

redis的分布式锁
锁的键值：订单号
获取锁： jedis.set(key,value,"NX","EX",expireTime) 注意：NX只有在键不存在时才进行设置操作，EX表示设置过期时间（不会一直占用）
释放锁： 使用lua脚本，获取key值并返回是否删除成功


消费：
在线消费
离线消费

流程：
1.家长教师通过手机端上传人脸,人脸通过审核后下发到设备上
2.学生刷脸进行消费
3.消费请求到后台进行处理


设计问题
补偿机制：
充值过程中会出现由于本身系统的bug的原因导致账单处理失败，而银行的订单已经处理成功，则要提供一个补偿机制，定期对系统内处理失败或待处理的订单通过订单号拉取银行的订单进行对比，若银行订单已处理成功，则对该订单进行充值逻辑
对账：
做这种消费系统时，应设计一个对账模块，将银行的充值账单和本地的订单做一个对比，好观察哪比订单出了问题

数据量估计：
学生 2500
教职工： 800

消费数据估算
（2500+800）*3*2 = 19800数据 将近20000数据一天
一年将近480万数据

轨迹数据：
超过500万

